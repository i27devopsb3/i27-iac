## Tasks
- Modify the `google_compute_instance` in a way it takes static ip only.
- Copy the private key generated by terraform  to all the machines
- Explore in a a way that `know_hosts` approval can be automated in ansible
- Create a backend solution to store the terraform statefile. 
- Store the statefile under a folder called as `infrastate` inside the bucket.
- Mention the bucket name dynamically during the runtime(terraform apply)
- Explore a way where i can mention the know_hosts approval rather than giving as `yes`

### Playbooks [Done]
- Create a playbook to install configure `sonar`

### Jenkins: 
- Create a small groovy script to list down all the plugins in my jenkins node.
- Make sure the user is having permsiosn to execute docker commands without sudo.


## Docker Deploy Tasks: [Done]
* Add a new node(docker) in the variable section of terraform
* Once the server is created ,  add the docker details in the inv file of ansible.
* Create a playbook to 
    * install docker 
    * to create a user specific to docker 
    * add user to docker group 
    * Set permission for docker.sock
    * Enable password authentication to ssh 
    * Restart ssh service 
    * add the user to sudoers file
* Run playbook , so docker installs 


## Prod Approval:
* Modify the pipeline to take tags with format `v.x.x.x` only to production.
* If the branch is a tag , then there is no way we can skip the scans.

## NodeApp
* Create a Dockerfile for node application, build and push to registry
* Test with a contianer 
* Create a similar Jenkinsfile like microservices for deployment on node application. 


## k8s 
* Create a method in src/com/i27academy/k8s/K8s.groovy
    * Create a method in a way that `gcloud auth activate-service-account jenkins@quantum-weft-420714.iam.gserviceaccount.com --key-file=key.json` is dynamically passed.
* Install Kubectl on the Slave using playbook task in slave machine.




## Next steps:
* Create some data into products database. 
    * for this lets use postname
    * use postman to do some operations
* Create a K8s Cluster. 
* Convert the API's and Frontend into k8s manifests.
* Modify the Jenkinsfiles to deploy to K8S Cluster instead of containers.
* Convert our Jenkins pipeline into Shared Libraries. 
* Move the registry from hub to jfrog and make them private.
* make the deployments using helma and modify the SharedLibrari accordingly.



